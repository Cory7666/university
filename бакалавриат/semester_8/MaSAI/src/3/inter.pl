%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Интерпретатор (машина вывода) для ЭС продукционного типа
% Метод вывода: обратный вывод
% Вариант 1: интерпретатор обрабатывает правила, в которых
% предпосылки задаются в виде условий (не более 2-х), соединенных
% оператором "and".
% -----------------------------------------------------------------------------
% Примеры правил см. в загружаемой тестовой базе знаний - nb.pl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:-dynamic reported/2.

% объявление операторов
define_operators:-
    op(920, xfy, and),
    op(950, xfx, then),
    op(960, fx, if),
    op(970, xfx, '::').
:-define_operators.

%============обратный вывод=======================================================
% реализуется предикатом find(H,Stack,Д), где H - проверяемая hypothesis (цель),
% Stack - Stack из имен доказываемых гипотез and правил (используется при ответе на
% вопросы "why"), Д - Tree вывода целевого утверждения (используется при отве-
% те на вопросы "how"). Предикат получает на вход Н and Stack=[H] and в процессе обрат-
% ного вывода строит Tree вывода Д.
%---------------------------------------------------------------------------------

% случай1:if цель Н была подтверждена пользователем,
% then Tree вывода Д=reported(Н).
find(H,Stack,reported(H)) :-
    reported(H, 'да').

% if цель - это sign, then ask его значение
find(H, Stack, reported(H)) :-
    requested(H),
    not(reported(H,_)),
    ask(H, Stack).

% случай2:if цель Н подтверждается фактом, уже известным системе,
% then Tree вывода Д=Fact :: H
find(H, Stack, Fact :: H) :-
    Fact :: H.

% случай3: if цель Н соответствует следствию одного из
% правил -> Rule :: if H1 then H
% and if D1 Tree вывода для подцели Н1,
% then Д= Rule :: if D1 then H and номер правила добавить в Stack
find(H, Stack, Rule :: if D1 then H) :-
    Rule :: if H1 then H,
    find(H1, [Rule | Stack], D1).

% случай4: if доказывается конъюнкция гипотез H=H1 and Н2,
% then Tree вывода Д=D1 and D2, где D1,D2 - деревья вывода гипотез H1 and Н2
find(H1 and H2,Stack,D1 and D2) :-
    find(H1, Stack, D1),
    find(H2, Stack, D2).

% проверка: является ли hypothesis признаком, значение которого
% можно спросить
requested(H) :-
    Fact :: sign(H).

%==== вывод вопросов and обработка ответов "да, нет, почему" =============
% вывод вопроса and ввод ответа
ask(H,Stack) :-
    write(H),
    write('?'),
    nl,
    read(O),
    answer(H, O, Stack).

% обработка ответов: да, нет.
answer(H,'да',Stack) :-
    assert(reported(H,'да')),!.
answer(H,'нет',Stack) :-
    assert(reported(H,'нет')),
    !,
    fail.

% обработка ответов "почему".

% случай1: Stack целей пустой
answer(H,'почему',[]) :-
    !,
    write(' Вы задали много вопросов.'),
    nl,
    ask(H,[]).

%случай2: в стеке только первая введенная цель, т.е. доказываемая гипотеза.
answer(H, 'почему', [H1]) :-
    !,
    write('моя гипотеза: '),
    write(H1),
    nl,
    ask(H,[]).

% случай3: if в стеке несколько элементов, then вывод заключения
% (т.е. подцели) and номера текущего применяемого правила.
answer(H, 'почему', [Rule | Stack]) :-
    !,
    Rule :: if H1 then H2,
    write(' пытаюсь доказать '),
    write(H2), nl,
    write(' используя правило '),
    write(Rule), nl,
    ask(H, Stack).

% неправильный answer: повторяем вопрос
answer(H,_,Stack) :-
    write(' ожидаемый ответ: да, нет, почему'),
    nl,
    ask(H, Stack).

%==============обработка ответов на вопросы "how?"===============================
% предикат how(H,Д)- выполняет поиск подцели Н в построенном
% с помощью предиката "find" дереве вывода Д and отображает соответствующий
% фрагмент дерева вывода, объясняя, how было получено доказательство Н.
% Tree вывода Д представляет собой последовательность вложенных правил, напри-
% мер:
% правило2::if (правило4::if reported(плита(холодная))and
% reported(лампа(не_светится))
% then тока(no))
% then выключатель(не_включен)
% --------------------------------------------------------------------------------

% поиск целевого утверждения Н в дереве
how(H,Tree) :-
    how1(H,Tree),
    !.

% вывод сообщения, if Н не найдено в дереве
how(H,_) :-
    write(H),
    tab(2),
    write(' не доказано.'),
    nl.

% случай1: if Н reported пользователем,
% then вывести "Н было введено"
how1(H,_) :-
    reported(H,_),
    !,
    write(H),
    write(' было введено.'),
    nl.

% случай2: if Tree вывода Д представлено фактом, подтверждающим Н
how1(H,Fact :: H) :-
    !,
    write(H),
    write( '- это факт '),
    write(Fact),
    nl.

% случай3: if Tree вывода Д - Rule в заключение, которого есть Н,
% then отобразить это Rule
how1(H,Rule :: if _ then H) :-
    !,
    write(H),
    write(' было доказано через '),
    nl,
    Rule :: if H1 then H,
    display_rule(Rule :: if H1 then H).

% случай4: if в дереве Д no правила с заключением Н,
%then поиск Н надо выполнять в дереве предпосылок, т.е. в Tree
how1(H,Rule :: if Tree then _) :-
    how(H,Tree).

% случай5: if предпосылки образуют конъюнкцию,
% then выполнить поиск в поддеревьях Tree1 and Tree2
how1(H,Rule :: if Tree1 and Tree2 then _) :-
    how(H,Tree1),
    how(H,Tree2).

%вывод правила на экран
display_rule(Rule :: if H1 then H):-
    write(Rule), write( ':'), nl,
    write('if '), write(H1), nl,
    write('then '), write(H), nl.

/* =====================Вызов интерпретатора===================================*/
init :-
    retractall(reported(_,_)).

start:-
    /* Загрузка базы знаний из файла */
    reconsult('task.pl'),
    info,
    go_exp_sys.

go_exp_sys :-
    init,
    Fact :: hypothesis(H),
    find(H,[H],Tree),
    write('решение:'),
    write(H),
    nl,
    explain(Tree),
    return.

%объяснение вывода утверждения
explain(Tree) :-
    write( 'Объяснить ? [цель/нет]:'),
    nl,
    read(H),
    (
        H \= 'нет',
        !,
        how(H, Tree),
        explain(Tree));
    !.

%поиск следующих решений
return :-
    nl,
    write('Продолжить? [ДА/нет]: '),
    nl,
    read(нет).
